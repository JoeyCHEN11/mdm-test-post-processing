import numpy as np
import torch
import pytorch3d.transforms

def load_mdm_to_smplx_params(npy_path: str, device: str = 'cpu') -> dict:
    """
    Read the .npy file generated by MDM and convert it into standard input parameters for the SMPL-X model.
    
    Args:
        npy_path (str): .npy file path
        device (str): Target device ('cpu' or 'cuda')
    
    Returns:
        dict: Dictionary containing SMPL-X parameters, all values are Tensors with shape (Frames, ...):
            - global_orient: (Frames, 1, 3) 
            - body_pose:     (Frames, 21, 3)
            - transl:        (Frames, 3)
            - betas:         (1, 10)  # Defaults to all zeros
    """
    
    # 1. Load numpy data
    # fix for numpy 2.0 comptibility inside legacy pickle files just in case
    if not hasattr(np, 'infty'):
        np.infty = np.inf
        
    print(f"[Data] Loading motion file: {npy_path}")
    data = np.load(npy_path, allow_pickle=True).item()
    
    # 2. Extract and standardize dimensions -> (Frames, Joints, 6)
    raw_thetas = data['thetas'] 
    
    # Handle Batch and Channel dimensions, target: [Frames, 24, 6]
    if len(raw_thetas.shape) == 4: # (Batch, Joints, 6, Frames)
        # Take Batch 0
        thetas_tensor = torch.from_numpy(raw_thetas[0]).permute(2, 0, 1).float()
    elif len(raw_thetas.shape) == 3: # (Joints, 6, Frames)
        thetas_tensor = torch.from_numpy(raw_thetas).permute(2, 0, 1).float()
    else:
        raise ValueError(f"Unknown thetas shape: {raw_thetas.shape}")

    # Slice the first 24 joints (SMPL standard)
    if thetas_tensor.shape[1] > 24:
        thetas_tensor = thetas_tensor[:, :24, :]
        
    # Handle translation: (3, Frames) -> (Frames, 3)
    transl_tensor = torch.from_numpy(data['root_translation']).permute(1, 0).float()
    
    # 3. Convert rotation format: 6D -> Matrix -> Axis-Angle
    # Optimization tasks are usually based on Axis-Angle or Matrix, here converted to Axis-Angle to adapt to SMPL-X forward
    with torch.no_grad():
        rot_mats = pytorch3d.transforms.rotation_6d_to_matrix(thetas_tensor)
        rot_axis_angle = pytorch3d.transforms.matrix_to_axis_angle(rot_mats) # Shape: [Frames, 24, 3]

    num_frames = rot_axis_angle.shape[0]

    # 4. Split parameters to adapt to SMPL-X Forward signature
    # SMPL-X definition:
    # Joint 0: root (global_orient)
    # Joints 1-21: body (body_pose)
    # Joints 22-23: smpl hands (usually ignored in smplx or as part of hand_pose; here we take the first 22 to maintain body pose)
    
    global_orient = rot_axis_angle[:, 0:1, :] # [Frames, 1, 3]
    body_pose = rot_axis_angle[:, 1:22, :]    # [Frames, 21, 3]

    # 5. Transfer to device
    device_obj = torch.device(device)
    output_params = {
        'global_orient': global_orient.to(device_obj),
        'body_pose': body_pose.to(device_obj),
        'transl': transl_tensor.to(device_obj),
        'betas': torch.zeros((1, 10), device=device_obj).float() # Default body shape
    }

    print(f"[Data] Data loading completed. Frames: {num_frames}, Device: {device}")
    return output_params